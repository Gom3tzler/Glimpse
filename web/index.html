<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glimpse</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#e5a00d">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Glimpse Media">
    <meta name="application-name" content="Glimpse Media Viewer">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="/images/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/images/android-chrome-592x592.png">

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">

    <style>
        :root {
            --poster-width: 200px;
            --primary-color: #e5a00d;
            --primary-hover: #f1b020;
            --primary-light: rgba(229, 160, 13, 0.1);
            --bg-color: #1a1a1a;
            --secondary-bg: #2a2a2a;
            --header-bg: #242424;
            --light-text: #fff;
            --muted-text: #aaa;
            --tab-bg: #333;
            --border-color: #555;
            --header-height: 70px;
            --mobile-header-height: 120px;
            --transition-speed: 0.3s;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            padding-top: var(--header-height);
            /* Space for sticky header */
            background-color: var(--bg-color);
            color: var(--light-text);
            line-height: 1.5;
            font-size: 16px;
        }

        /* Enhanced Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background-color: var(--header-bg);
            z-index: 100;
            transition: height var(--transition-speed), box-shadow var(--transition-speed);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            height: 100%;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h1 {
            color: var(--primary-color);
            margin: 0;
            white-space: nowrap;
            font-size: 1.6rem;
            letter-spacing: -0.5px;
            font-weight: 700;
            transition: font-size var(--transition-speed);
            display: flex;
            align-items: center;
        }

        .logo-icon {
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-right: 8px;
        }

        /* Tabs with pill styling */
        .tabs {
            display: flex;
            gap: 10px;
            transition: all var(--transition-speed);
        }

        .tab {
            padding: 8px 18px;
            cursor: pointer;
            background-color: var(--tab-bg);
            border: none;
            border-radius: 20px;
            transition: all var(--transition-speed);
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .tab.active {
            background-color: var(--primary-color);
            color: #000;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }

        .tab:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Enhanced search */
        .search-box {
            flex: 1;
            text-align: center;
            position: relative;
            display: flex;
            justify-content: center;
        }

        .search-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            display: inline-block;
        }

        .search-input {
            padding: 10px 36px 10px 16px;
            width: 100%;
            box-sizing: border-box;
            border: none;
            border-radius: 20px;
            background-color: rgba(0, 0, 0, 0.25);
            color: var(--light-text);
            font-size: 0.95rem;
            transition: all var(--transition-speed);
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .search-input:focus {
            background-color: rgba(0, 0, 0, 0.35);
            box-shadow: 0 0 0 2px rgba(229, 160, 13, 0.4);
        }

        .search-input::placeholder {
            color: var(--muted-text);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted-text);
            font-size: 0.95rem;
        }

        .search-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--muted-text);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            display: none;
            line-height: 0;
            transition: color var(--transition-speed);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            z-index: 1;
        }

        .search-clear:hover {
            color: var(--primary-color);
            background-color: rgba(255, 255, 255, 0.05);
        }

        .search-clear.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Sort Toggle Styles */
        .sort-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }

        .sort-button,
        .genre-button {
            padding: 6px 12px;
            cursor: pointer;
            background-color: var(--tab-bg);
            border: none;
            border-radius: 20px;
            transition: all var(--transition-speed);
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.85rem;
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sort-button.active,
        .genre-button.active {
            background-color: var(--primary-color);
            color: #000;
            font-weight: 600;
        }

        .sort-button:hover:not(.active),
        .genre-button:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sort-icon {
            font-size: 0.9rem;
        }

        /* Desktop Genre dropdown styles */
        .genre-dropdown {
            position: relative;
            display: inline-block;
        }

        .genre-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            /* Position from right instead of left */
            margin-top: 5px;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            overflow: hidden;
            z-index: 10;
            min-width: 180px;
            max-width: 300px;
            /* Set a max width to prevent it from getting too large */
            max-height: 300px;
            overflow-y: auto;
        }

        /* For dropdowns near the left edge of the screen */
        .genre-dropdown:first-child .genre-menu {
            left: 0;
            right: auto;
        }

        .genre-menu.show {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .genre-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: all var(--transition-speed);
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .genre-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .genre-item.active {
            background-color: var(--primary-light);
            color: var(--primary-color);
            font-weight: 600;
        }

        .genre-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-color: var(--primary-color);
            color: #000;
            border-radius: 10px;
            padding: 3px 8px;
            font-weight: 600;
            font-size: 0.7rem;
            margin-left: 5px;
            min-width: 20px;
        }

        .selected-genre {
            font-weight: 600;
            max-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Content area styling */
        .content {
            display: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity var(--transition-speed), transform var(--transition-speed);
        }

        .content.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--poster-width), 1fr));
            gap: 20px;
            padding: 20px 0;
            margin-bottom: 60px;
        }

        /* Enhanced media items */
        .media-item {
            background-color: var(--secondary-bg);
            border-radius: 12px;
            overflow: hidden;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed);
            display: flex;
            flex-direction: column;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .media-item:hover {
            transform: translateY(-5px);
        }

        .poster-container {
            position: relative;
            width: 100%;
            aspect-ratio: 2/3;
            background-color: var(--tab-bg);
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }

        .poster {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            background-color: var(--tab-bg);
            opacity: 0;
            transition: opacity var(--transition-speed) ease-in;
        }

        .poster.loaded {
            opacity: 1;
        }

        /* Improved loading animation */
        .poster-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--tab-bg);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(0, 0, 0, 0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spinner-rotate 1s linear infinite;
        }

        @keyframes spinner-rotate {
            to {
                transform: rotate(360deg);
            }
        }

        /* Media item info section */
        .media-info {
            padding: 15px;
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .media-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 5px;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: block;
            width: 100%;
            box-sizing: border-box;
            transition: color var(--transition-speed);
        }

        .media-title:hover {
            color: var(--primary-color);
        }

        .media-year {
            color: var(--muted-text);
            font-size: 0.85rem;
            margin-top: auto;
        }

        /* Added date indicator */
        .media-added {
            color: var(--muted-text);
            font-size: 0.8rem;
            margin-top: 5px;
            display: none;
            transition: opacity var(--transition-speed);
        }

        .sort-by-date .media-added {
            display: block;
        }

        /* Loading and error states */
        .loading {
            text-align: center;
            font-size: 1.2em;
            color: var(--primary-color);
            padding: 30px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 15px;
            margin-top: 35vh;
        }

        .loading .loading-spinner {
            width: 40px;
            height: 40px;
        }

        .error {
            text-align: center;
            color: #ff4444;
            padding: 20px;
            background-color: rgba(255, 68, 68, 0.1);
            border-radius: 8px;
            margin: 20px 0;
        }

        /* Enhanced scroll to top button */
        .scroll-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: var(--primary-color);
            color: #000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            transition: background-color var(--transition-speed),
                opacity var(--transition-speed),
                transform var(--transition-speed);
            opacity: 0;
            z-index: 1000;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            font-family: monospace;
            transform: scale(0.8) translateY(20px);
        }

        .scroll-to-top::before {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border-top: 3px solid #000;
            border-right: 3px solid #000;
            transform: rotate(-45deg);
            top: 35%;
            left: 50%;
            margin-top: 2px;
            margin-left: -7px;
            transition: inherit;
        }

        .scroll-to-top:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05) translateY(0);
        }

        .scroll-to-top.visible {
            display: flex;
            opacity: 0.95;
            transform: scale(1) translateY(0);
        }

        /* Enhanced Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity var(--transition-speed) ease;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            position: relative;
            background-color: var(--secondary-bg);
            border-radius: 16px;
            max-width: 1000px;
            width: 100%;
            margin: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            max-height: 90vh;
            transform: translateY(30px);
            transition: transform var(--transition-speed) ease;
            overflow: hidden;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 280px;
            background-size: cover;
            background-position: center center;
            opacity: 0.35;
            z-index: 0;
        }

        .modal-backdrop::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(42, 42, 42, 0.3) 0%, var(--secondary-bg) 100%);
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            align-items: flex-end;
            padding: 30px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 1;
        }

        .modal-poster {
            width: 180px;
            flex-shrink: 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            margin-right: 25px;
            transition: transform var(--transition-speed);
        }

        .modal-poster img {
            width: 100%;
            height: auto;
            display: block;
        }

        .modal-title {
            margin: 0 0 10px 0;
            font-size: 2.2em;
            color: var(--light-text);
            font-weight: 700;
            line-height: 1.1;
        }

        .modal-year {
            font-size: 1.2em;
            color: var(--muted-text);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .modal-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .metadata-item {
            padding: 6px 12px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.4);
            border: none;
            color: var(--light-text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-speed);
            padding: 0;
            z-index: 10;
        }

        .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-hover);
        }

        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(0, 0, 0, 0.2);
            scroll-behavior: smooth;
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 30px;
            max-height: calc(90vh - 180px);
            position: relative;
            z-index: 1;
            scroll-behavior: smooth;
        }

        .modal-section {
            margin-bottom: 5px;
        }

        .modal-section-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-weight: 600;
        }

        .summary-section {
            line-height: 1.7;
            color: var(--light-text);
        }

        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .cast-item {
            background-color: rgba(0, 0, 0, 0.15);
            border-radius: 10px;
            padding: 15px;
            transition: transform var(--transition-speed), background-color var(--transition-speed);
        }

        .cast-name {
            font-weight: 600;
        }

        .cast-role {
            color: var(--muted-text);
            font-size: 0.9em;
        }

        .genres-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .genre-tag {
            background-color: rgba(229, 160, 13, 0.2);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 0.9em;
            transition: background-color var(--transition-speed);
            font-weight: 500;
        }

        .genre-tag:hover {
            background-color: rgba(229, 160, 13, 0.3);
        }

        /* Mobile menu button */
        .mobile-menu-button {
            display: none;
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: none;
            color: var(--light-text);
            font-size: 24px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
        }

        /* Mobile menu */
        .mobile-menu {
            position: fixed;
            top: var(--mobile-header-height);
            left: 0;
            width: 100%;
            background-color: var(--header-bg);
            z-index: 99;
            padding: 15px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
            transform: translateY(-100%);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .mobile-menu.open {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .mobile-menu .tabs {
            flex-direction: column;
            width: 100%;
        }

        .mobile-menu .tab {
            width: 100%;
            text-align: center;
            padding: 12px;
            border-radius: 8px;
        }

        /* Sort toggle for mobile menu */
        .mobile-menu .sort-toggle {
            display: flex;
            margin-top: 15px;
            margin-left: 0;
            justify-content: center;
            width: 100%;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-menu .sort-row {
            display: flex;
            width: 100%;
            gap: 10px;
            justify-content: center;
        }

        .mobile-menu .sort-button {
            flex: 1;
            justify-content: center;
            padding: 10px;
            min-width: 80px;
        }

        .mobile-menu #mobile-genre-button {
            width: 100%;
            margin-top: 5px;
        }

        /* NEW MOBILE GENRE DRAWER */
        .genre-drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1001;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .genre-drawer-overlay.open {
            display: block;
            opacity: 1;
        }

        .genre-drawer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--secondary-bg);
            border-radius: 16px 16px 0 0;
            z-index: 1002;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
            max-height: 70vh;
            display: flex;
            flex-direction: column;
        }

        .genre-drawer.open {
            transform: translateY(0);
        }

        .genre-drawer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .genre-drawer-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--light-text);
            flex: 1;
            text-align: center;
        }

        .genre-drawer-close {
            position: absolute;
            right: 15px;
            top: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.3);
            border: none;
            border-radius: 50%;
            color: var(--light-text);
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .genre-drawer-content {
            overflow-y: auto;
            padding: 10px 0;
            max-height: calc(70vh - 70px);
        }

        .genre-drawer .genre-item {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .genre-drawer .genre-item:last-child {
            border-bottom: none;
        }

        .genre-drawer .genre-item.active {
            background-color: var(--primary-light);
        }

        /* Apply drawer to mobile genre buttons */
        @media screen and (max-width: 992px) {
            .sort-toggle .genre-dropdown .genre-menu {
                display: none !important;
                /* Never show dropdown menu on mobile */
            }
        }

        /* No results message */
        .no-results {
            display: none;
            text-align: center;
            padding: 20px 30px 40px;
            color: var(--light-text);
            border-radius: 12px;
            height: 100vh;
            margin: 40px auto;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity var(--transition-speed), transform var(--transition-speed);
            box-shadow: var(--shadow-sm);
        }

        .no-results.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .no-results-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            display: block;
        }

        .no-results-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .no-results-message {
            color: var(--muted-text);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .search-term {
            color: var(--primary-color);
            font-weight: 600;
            word-break: break-word;
        }

        /* Text placeholder styles for missing images */
        .text-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(145deg, #333, #222);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(229, 160, 13, 0.2);
            overflow: hidden;
        }

        .text-placeholder .media-initial {
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .text-placeholder .media-name {
            font-size: 0.9rem;
            font-weight: 500;
            line-height: 1.2;
            opacity: 0.8;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .text-placeholder.large {
            background: linear-gradient(145deg, #333, #222);
        }

        .text-placeholder.large .media-initial {
            font-size: 5rem;
            margin-bottom: 15px;
        }

        .text-placeholder.large .media-name {
            font-size: 1.5rem;
            -webkit-line-clamp: 2;
        }

        .backdrop-text-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(42, 42, 42, 0.8), var(--secondary-bg));
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            padding: 20px;
            opacity: 0.5;
            z-index: 0;
        }

        /* Touch target sizing for mobile */
        @media (pointer: coarse) {
            .media-title {
                padding: 5px 0;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
        }

        /* Swipe indicator styles */
        .swipe-indicator {
            display: none;
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 90;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: auto;
            max-width: 80%;
        }

        /* Mobile responsiveness */
        @media screen and (max-width: 992px) {
            .sort-toggle {
                display: none;
            }
        }

        @media screen and (max-width: 768px) {
            :root {
                --mobile-header-height: 70px;
            }

            body {
                padding-top: var(--mobile-header-height);
            }

            .header {
                height: var(--mobile-header-height);
            }

            .header-content {
                justify-content: space-between;
                padding: 0 15px;
            }

            .logo-section {
                order: 1;
            }

            h1 {
                font-size: 1.3rem;
            }

            .search-box {
                order: 2;
                flex: 1;
            }

            .search-input {
                padding: 8px 30px 8px 10px;
                font-size: 0.9rem;
            }

            .header-content .tabs {
                display: none;
            }

            .mobile-menu-button {
                display: flex;
                order: 3;
            }

            .mobile-menu {
                display: block;
            }

            .modal-header {
                margin-top: 40px;
                padding: 20px;
                gap: 20px;
            }

            .modal-poster {
                margin-right: 0;
                margin-bottom: 20px;
                width: 130px;
                align-self: center;
            }

            .modal-title {
                font-size: 1.5em;

            }

            .media-title {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .modal-body {
                padding: 20px;
                gap: 20px;
                scroll-behavior: smooth;
            }

            .cast-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .loading {
                margin-top: 35vh;
            }

            .search-container {
                max-width: 100%;
            }

            /* Show swipe indicator on mobile */
            .swipe-indicator {
                display: block;
            }
        }

        @media screen and (max-width: 600px) {
            :root {
                --poster-width: 150px;
            }

            .container {
                padding: 0 10px;
            }

            .scroll-to-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            .media-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 15px 0;
            }

            .media-info {
                padding: 12px;
            }

            .media-title {
                font-size: 0.9em;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .media-year {
                font-size: 0.8em;
            }

            .media-added {
                font-size: 0.75em;
            }

            .modal-header {
                margin-top: 40px;
            }

            .modal-title {
                font-size: 1.4em;
            }

            .modal-body {
                scroll-behavior: smooth;
            }

            .modal-section-title {
                font-size: 1.1em;
            }

            .cast-grid {
                grid-template-columns: 1fr 1fr;
            }

            .cast-item {
                padding: 12px;
            }

            .loading {
                margin-top: 35vh;
            }

            .search-container {
                max-width: 100%;
            }
        }

        /* Hide scroll-to-top when modal is open */
        .modal-overlay.active~.scroll-to-top {
            display: none !important;
            opacity: 0;
            visibility: hidden;
        }

        .logo-icon img {
            height: 50px;
            border-radius: 20%;
            margin-top: 15px;
        }

        /* Server Toggle Styles */
        .server-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 15px;
        }

        .server-toggle-button {
            background-color: var(--tab-bg);
            color: var(--light-text);
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all var(--transition-speed);
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }

        .server-toggle-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .server-icon {
            font-size: 1rem;
        }

        @media screen and (max-width: 768px) {
            .server-toggle {
                margin-left: 10px;
            }

            .server-toggle-button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            .server-text {
                display: none;
            }
        }

        @media screen and (max-width: 480px) {
            .server-toggle-button {
                padding: 6px 8px;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-content">
            <div class="logo-section">
                <h1><span class="logo-icon"><img src="images/logo.png" /></span>Glimpse</h1>
            </div>
            <div class="search-box">
                <div class="search-container">
                    <input type="text" class="search-input" placeholder="Search...">
                    <button class="search-clear" aria-label="Clear search">×</button>
                </div>
            </div>
            <div class="tabs">
                <div class="tab active" data-content="movies">Movies</div>
                <div class="tab" data-content="tvshows">TV Shows</div>
                <!-- Sort toggle for desktop -->
                <div class="sort-toggle">
                    <button class="sort-button active" data-sort="alpha">
                        <span class="sort-icon">A-Z</span>
                    </button>
                    <button class="sort-button" data-sort="date">
                        <span class="sort-icon">📅 Date Added ▼</span>
                    </button>
                    <!-- Genre filter dropdown -->
                    <div class="genre-dropdown">
                        <button class="sort-button genre-button" data-filter="genre">
                            <span class="sort-icon">🏷️ Genre</span>
                        </button>
                        <div class="genre-menu">
                            <div class="genre-item active" data-genre="all">All Genres</div>
                            <!-- Genre items will be populated dynamically -->
                        </div>
                    </div>
                    <!-- Server Toggle (only shows when both servers configured) -->
                    <div class="server-toggle">
                        <button class="server-toggle-button" onclick="toggleServer()">
                            <span class="server-icon">🔄</span>
                            <span class="server-text">Switch to SERVER_NAME</span>
                        </button>
                    </div>
                </div>
            </div>
            <button class="mobile-menu-button" aria-label="Menu">☰</button>
        </div>
    </div>

    <!-- Mobile Menu -->
    <div class="mobile-menu">
        <div class="tabs">
            <div class="tab active" data-content="movies">Movies</div>
            <div class="tab" data-content="tvshows">TV Shows</div>
        </div>
        <!-- Sort toggle for mobile menu -->
        <div class="sort-toggle">
            <div class="sort-row">
                <button class="sort-button active" data-sort="alpha">
                    <span class="sort-icon">A-Z</span>
                </button>
                <button class="sort-button" data-sort="date">
                    <span class="sort-icon">📅 Date Added ▼</span>
                </button>
            </div>
            <!-- Mobile Genre button - now triggers drawer -->
            <button class="sort-button genre-button" id="mobile-genre-button">
                <span class="sort-icon">🏷️ Genre</span>
            </button>
        </div>
    </div>

    <!-- NEW MOBILE GENRE DRAWER -->
    <div class="genre-drawer-overlay">
        <div class="genre-drawer">
            <div class="genre-drawer-header">
                <div class="genre-drawer-title">Select Genre</div>
                <button class="genre-drawer-close">×</button>
            </div>
            <div class="genre-drawer-content">
                <!-- Genre items will be populated dynamically -->
                <div class="genre-item active" data-genre="all">All Genres</div>
            </div>
        </div>
    </div>

    <div class="container">
        <div id="movies-content" class="content active">
            <div class="loading">
                <div class="loading-spinner"></div>
            </div>
            <div class="no-results">
                <span class="no-results-icon">🔍</span>
                <h3 class="no-results-title">No results found</h3>
                <p class="no-results-message">We couldn't find any Movies matching "<span class="search-term"></span>"
                </p>
                <p>Try searching for something else or clearing your search</p>
            </div>
            <div class="media-grid"></div>
        </div>

        <div id="tvshows-content" class="content">
            <div class="loading">
                <div class="loading-spinner"></div>
            </div>
            <div class="no-results">
                <span class="no-results-icon">🔍</span>
                <h3 class="no-results-title">No results found</h3>
                <p class="no-results-message">We couldn't find any TV Shows matching "<span class="search-term"></span>"
                </p>
                <p>Try searching for something else or clearing your search</p>
            </div>
            <div class="media-grid"></div>
        </div>
    </div>

    <!-- Swipe Indicator -->
    <div class="swipe-indicator"></div>

    <!-- Modal -->
    <div class="modal-overlay">
        <div class="modal-content">
            <div class="modal-backdrop"></div>
            <button class="modal-close" aria-label="Close modal">×</button>
            <div class="modal-header">
                <div class="modal-poster">
                    <!-- Poster will be populated dynamically -->
                </div>
                <div class="modal-title-section">
                    <h2 class="modal-title">Movie Title</h2>
                    <div class="modal-year">2023</div>
                    <div class="modal-metadata">
                        <div class="metadata-item" id="modal-rating">PG-13</div>
                        <div class="metadata-item" id="modal-duration">120 min</div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <div class="modal-section summary-section">
                    <div class="modal-section-title">Overview</div>
                    <div id="modal-summary">Loading summary...</div>
                </div>

                <div class="modal-section">
                    <div class="modal-section-title">Genres</div>
                    <div class="genres-list" id="modal-genres">
                        <!-- Genres will be added here -->
                    </div>
                </div>

                <div class="modal-section">
                    <div class="modal-section-title">Cast</div>
                    <div class="cast-grid" id="modal-cast">
                        <!-- Cast members will be added here -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <button class="scroll-to-top" aria-label="Scroll to top"></button>

    <script>
        let moviesData = [];
        let tvShowsData = [];
        let currentSortMethod = 'alpha'; // Default sorting method: 'alpha' or 'date'
        let currentGenre = 'all'; // Default genre filter: 'all' or specific genre
        let allGenres = { movies: {}, tvshows: {} }; // Store all unique genres and their counts
        let isMobileView = window.innerWidth < 992; // Track if we're in mobile view

        // Function to check if device is mobile/tablet
        function checkMobileView() {
            isMobileView = window.innerWidth < 992;
            return isMobileView;
        }

        // Update on resize
        window.addEventListener('resize', checkMobileView);

        // Function to create text placeholders for missing images
        function createTextPlaceholder(container, title) {
            const placeholder = document.createElement('div');
            placeholder.className = 'text-placeholder';
            placeholder.innerHTML = `
                <div class="media-name">${title}</div>
            `;

            container.appendChild(placeholder);
            return placeholder;
        }

        // Format timestamp to readable date
        function formatDate(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        }

        // Set up Intersection Observer for lazy loading
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const placeholder = img.parentElement.querySelector('.poster-placeholder');

                    img.onload = () => {
                        img.classList.add('loaded');
                        if (placeholder) {
                            placeholder.style.opacity = '0';
                            setTimeout(() => {
                                if (placeholder) placeholder.remove();
                            }, 300);
                        }
                    };

                    img.onerror = () => {
                        // Get the media title from the parent item
                        const mediaItem = img.closest('.media-item');
                        const title = mediaItem.querySelector('.media-title').textContent;

                        // Create a text placeholder
                        const textPlaceholder = createTextPlaceholder(img.parentElement, title);

                        // Hide the loading placeholder and the img
                        if (placeholder) {
                            placeholder.style.opacity = '0';
                            setTimeout(() => {
                                if (placeholder) placeholder.remove();
                            }, 300);
                        }
                        img.style.display = 'none';
                    };

                    img.src = img.dataset.src;
                    imageObserver.unobserve(img);
                }
            });
        }, {
            rootMargin: '100px 0px',  // Load images 100px before they enter viewport
            threshold: 0.01
        });

        // Mobile menu functionality
        const mobileMenuButton = document.querySelector('.mobile-menu-button');
        const mobileMenu = document.querySelector('.mobile-menu');

        mobileMenuButton.addEventListener('click', () => {
            mobileMenu.classList.toggle('open');
        });

        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
            if (mobileMenu.classList.contains('open') &&
                !mobileMenu.contains(e.target) &&
                !mobileMenuButton.contains(e.target)) {
                mobileMenu.classList.remove('open');
            }
        });

        // Function to switch tabs - UPDATED TO MAINTAIN GENRE FILTER
        function switchTab(contentName) {
            // Get current search query before switching tabs
            const currentSearchTerm = document.querySelector('.search-input').value.toLowerCase();

            // Update active tab (both mobile and desktop)
            document.querySelectorAll('.tab').forEach(t => {
                if (t.dataset.content === contentName) {
                    t.classList.add('active');
                } else {
                    t.classList.remove('active');
                }
            });

            // Update active content
            document.querySelectorAll('.content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(contentName + '-content').classList.add('active');

            // Check if the current genre exists in the new tab's genres
            if (currentGenre !== 'all' && !allGenres[contentName][currentGenre]) {
                // Reset genre filter if the genre doesn't exist in the new tab
                currentGenre = 'all';
                document.body.classList.remove('sort-by-genre');
            } else {
                // Keep the current genre selected
                document.body.classList.toggle('sort-by-genre', currentGenre !== 'all');
            }

            // Update the genre drawer and dropdown for the new tab
            updateGenreUI(contentName);

            // Apply the current search and sort to the newly selected tab content
            filterAndSortMedia(currentSearchTerm);

            // Close mobile menu if open
            mobileMenu.classList.remove('open');

            // Scroll to top when switching tabs
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Tab switching - update for both desktop and mobile tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchTab(tab.dataset.content);
            });
        });

        // Sort toggle functionality with direction support
        let sortDirection = {
            'alpha': 'asc',
            'date': 'desc'
        };

        function setSortMethod(method) {
            const previousMethod = currentSortMethod;

            // If clicking the same method, toggle direction
            if (method === previousMethod) {
                sortDirection[method] = sortDirection[method] === 'asc' ? 'desc' : 'asc';
            }

            currentSortMethod = method;

            // Update active state on all sort buttons
            document.querySelectorAll('.sort-button').forEach(btn => {
                if (btn.dataset.sort === method) {
                    btn.classList.add('active');

                    // Update the icon/text based on current direction
                    const iconSpan = btn.querySelector('.sort-icon');
                    if (method === 'alpha') {
                        iconSpan.textContent = sortDirection[method] === 'asc' ? 'A-Z' : 'Z-A';
                    } else if (method === 'date') {
                        iconSpan.textContent = sortDirection[method] === 'desc' ? '📅 Date Added ▼' : '📅 Date Added ▲';
                    }
                } else if (!btn.classList.contains('genre-button')) {
                    btn.classList.remove('active');
                }
            });

            // Update body class for styling
            if (method === 'date') {
                document.body.classList.add('sort-by-date');
                document.body.classList.remove('sort-by-genre');
            } else {
                document.body.classList.remove('sort-by-date');
            }

            // Reapply current search with new sorting
            const currentSearchTerm = document.querySelector('.search-input').value.toLowerCase();
            filterAndSortMedia(currentSearchTerm);
        }

        // Set the genre filter
        function setGenreFilter(genre) {
            currentGenre = genre;

            // Update active state in drawers and dropdowns
            document.querySelectorAll('.genre-item').forEach(item => {
                item.classList.toggle('active', item.dataset.genre === genre);
            });

            // Update genre button label and active state - for both desktop and mobile
            document.querySelectorAll('.genre-button').forEach(button => {
                if (genre !== 'all') {
                    // Don't update the text of the mobile drawer button - it's always just "Genre"
                    if (button.id !== 'mobile-genre-button') {
                        button.innerHTML = `<span class="sort-icon">🏷️ <span class="selected-genre">${genre}</span></span>`;
                    } else {
                        button.innerHTML = `<span class="sort-icon">🏷️ ${genre}</span>`;
                    }
                    button.classList.add('active');
                    document.body.classList.add('sort-by-genre');
                } else {
                    button.innerHTML = `<span class="sort-icon">🏷️ Genre</span>`;
                    button.classList.remove('active');
                    document.body.classList.remove('sort-by-genre');
                }
            });

            // Maintain the current sort method - keep Sort buttons active status
            document.querySelectorAll('.sort-button').forEach(btn => {
                if (btn.dataset.sort === currentSortMethod) {
                    btn.classList.add('active');
                } else if (!btn.classList.contains('genre-button')) {
                    btn.classList.remove('active');
                }
            });

            // Re-filter media with current search term and sort method
            const currentSearchTerm = document.querySelector('.search-input').value.toLowerCase();
            filterAndSortMedia(currentSearchTerm);

            // Close genre drawer if it's open
            closeGenreDrawer();
        }

        // Add event listeners to sort buttons
        document.querySelectorAll('.sort-button').forEach(button => {
            if (button.dataset.sort) {  // Only for actual sort buttons, not genre buttons
                button.addEventListener('click', () => {
                    setSortMethod(button.dataset.sort);

                    // Close mobile menu if open
                    mobileMenu.classList.remove('open');

                    // Scroll to top when sort method changes
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            }
        });

        // Handle desktop genre dropdown button clicks
        document.querySelectorAll('.genre-dropdown .genre-button').forEach(button => {
            button.addEventListener('click', (e) => {
                if (checkMobileView()) {
                    // On mobile, we'll use the drawer instead
                    return;
                }

                // Toggle the desktop genre dropdown
                const dropdown = button.closest('.genre-dropdown');
                const menu = dropdown.querySelector('.genre-menu');

                // Close other dropdowns first
                document.querySelectorAll('.genre-menu.show').forEach(m => {
                    if (m !== menu) {
                        m.classList.remove('show');
                    }
                });

                // Check if dropdown would overflow the window and adjust position
                setTimeout(() => {
                    const menuRect = menu.getBoundingClientRect();
                    const windowWidth = window.innerWidth;

                    // Only needed as a fallback if CSS positioning doesn't work
                    if (menuRect.right > windowWidth) {
                        menu.style.left = 'auto';
                        menu.style.right = '0';
                    }
                }, 0);

                menu.classList.toggle('show');
                e.stopPropagation(); // Prevent the document click handler from immediately closing it
            });
        });

        // Mobile genre drawer functionality
        const genreDrawerOverlay = document.querySelector('.genre-drawer-overlay');
        const genreDrawer = document.querySelector('.genre-drawer');
        const mobileGenreButton = document.getElementById('mobile-genre-button');
        const genreDrawerClose = document.querySelector('.genre-drawer-close');

        // Open genre drawer on mobile
        mobileGenreButton.addEventListener('click', () => {
            openGenreDrawer();

            // Close mobile menu if open
            mobileMenu.classList.remove('open');
        });

        // Close genre drawer when clicking the close button
        genreDrawerClose.addEventListener('click', closeGenreDrawer);

        // Close genre drawer when clicking the overlay
        genreDrawerOverlay.addEventListener('click', (e) => {
            if (e.target === genreDrawerOverlay) {
                closeGenreDrawer();
            }
        });

        // Function to open the genre drawer
        function openGenreDrawer() {
            // Make sure drawer content is up to date
            const activeTab = document.querySelector('.tab.active').dataset.content;
            updateGenreDrawer(activeTab);

            genreDrawerOverlay.classList.add('open');
            genreDrawer.classList.add('open');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        // Function to close the genre drawer
        function closeGenreDrawer() {
            genreDrawerOverlay.classList.remove('open');
            genreDrawer.classList.remove('open');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Close desktop genre dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.genre-dropdown')) {
                document.querySelectorAll('.genre-menu').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });

        // Function to extract and count all unique genres from media data
        function extractGenres(mediaData, type) {
            const genres = {};

            mediaData.forEach(item => {
                if (item.genres && Array.isArray(item.genres)) {
                    item.genres.forEach(genre => {
                        if (!genres[genre]) {
                            genres[genre] = 0;
                        }
                        genres[genre]++;
                    });
                }
            });

            // Sort genres alphabetically
            return Object.keys(genres)
                .sort()
                .reduce((result, key) => {
                    result[key] = genres[key];
                    return result;
                }, {});
        }

        // Function to update desktop genre dropdown with available genres
        function updateGenreDropdown(type) {
            const genres = allGenres[type];
            const dropdowns = document.querySelectorAll('.genre-menu');

            // Update genre menus (desktop only)
            dropdowns.forEach(dropdown => {
                // Keep the "All Genres" item
                dropdown.innerHTML = `<div class="genre-item ${currentGenre === 'all' ? 'active' : ''}" data-genre="all">All Genres</div>`;

                // Add each genre with count
                Object.entries(genres).forEach(([genre, count]) => {
                    const genreItem = document.createElement('div');
                    genreItem.className = `genre-item ${currentGenre === genre ? 'active' : ''}`;
                    genreItem.dataset.genre = genre;
                    genreItem.innerHTML = `${genre} <span class="genre-badge">${count}</span>`;
                    dropdown.appendChild(genreItem);
                });
            });

            // Add click event listeners to desktop genre items
            document.querySelectorAll('.genre-menu .genre-item').forEach(item => {
                item.addEventListener('click', () => {
                    setGenreFilter(item.dataset.genre);

                    // Close dropdown
                    document.querySelectorAll('.genre-menu').forEach(menu => {
                        menu.classList.remove('show');
                    });

                    // Scroll to top
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            });

            // Set button text based on current selection
            document.querySelectorAll('.genre-button').forEach(button => {
                if (currentGenre !== 'all') {
                    if (button.id === 'mobile-genre-button') {
                        // For mobile button, show genre name directly
                        button.innerHTML = `<span class="sort-icon">🏷️ ${currentGenre}</span>`;
                    } else {
                        // Desktop buttons get the nested span structure
                        button.innerHTML = `<span class="sort-icon">🏷️ <span class="selected-genre">${currentGenre}</span></span>`;
                    }
                    button.classList.add('active');
                } else {
                    button.innerHTML = `<span class="sort-icon">🏷️ Genre</span>`;
                    button.classList.remove('active');
                }
            });
        }

        // Function to update mobile genre drawer with available genres
        function updateGenreDrawer(type) {
            const genres = allGenres[type];
            const drawerContent = document.querySelector('.genre-drawer-content');

            // Clear current content
            drawerContent.innerHTML = '';

            // Add "All Genres" item
            const allGenresItem = document.createElement('div');
            allGenresItem.className = `genre-item ${currentGenre === 'all' ? 'active' : ''}`;
            allGenresItem.dataset.genre = 'all';
            allGenresItem.innerHTML = 'All Genres';
            drawerContent.appendChild(allGenresItem);

            // Add each genre with count
            Object.entries(genres).forEach(([genre, count]) => {
                const genreItem = document.createElement('div');
                genreItem.className = `genre-item ${currentGenre === genre ? 'active' : ''}`;
                genreItem.dataset.genre = genre;
                genreItem.innerHTML = `${genre} <span class="genre-badge">${count}</span>`;
                drawerContent.appendChild(genreItem);
            });

            // Update drawer title
            const drawerTitle = document.querySelector('.genre-drawer-title');
            drawerTitle.textContent = `${type === 'movies' ? 'Movie' : 'TV Show'} Genres`;

            // Add click event listeners to drawer genre items
            document.querySelectorAll('.genre-drawer-content .genre-item').forEach(item => {
                item.addEventListener('click', () => {
                    setGenreFilter(item.dataset.genre);
                });
            });
        }

        // Combined function to update both genre UI components
        function updateGenreUI(type) {
            updateGenreDropdown(type);
            updateGenreDrawer(type);
        }

        // Enhanced search functionality
        const searchInput = document.querySelector('.search-input');
        const searchClear = document.querySelector('.search-clear');

        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterAndSortMedia(searchTerm);

            // Toggle clear button visibility
            if (searchTerm) {
                searchClear.classList.add('visible');
            } else {
                searchClear.classList.remove('visible');
            }
        });

        searchClear.addEventListener('click', () => {
            searchInput.value = '';
            searchClear.classList.remove('visible');
            filterAndSortMedia('');
            searchInput.focus();
        });

        // Load and display media data
        async function loadMedia() {
            try {
                // Load movies
                const moviesResponse = await fetch('data/movies.json');
                moviesData = await moviesResponse.json();

                // Load TV shows
                const tvShowsResponse = await fetch('data/tvshows.json');
                tvShowsData = await tvShowsResponse.json();

                // Extract genres
                allGenres.movies = extractGenres(moviesData, 'movies');
                allGenres.tvshows = extractGenres(tvShowsData, 'tvshows');

                // Initialize genre UI for both desktop and mobile
                updateGenreUI('movies');

                // Initial sort and display
                filterAndSortMedia('');
            } catch (error) {
                console.error('Error loading media data:', error);
                document.querySelector('#movies-content .loading').innerHTML =
                    '<div class="error">Failed to load movie data. Please try again later.</div>';
                document.querySelector('#tvshows-content .loading').innerHTML =
                    '<div class="error">Failed to load TV show data. Please try again later.</div>';
            }
        }

        // Function to remove articles for sorting
        function removeArticles(title) {
            // Convert to lowercase and trim spaces
            let cleanTitle = title.toLowerCase().trim();
            // Remove leading articles: "the ", "a ", "an "
            cleanTitle = cleanTitle.replace(/^(the|a|an)\s+/i, '');
            return cleanTitle;
        }

        // Natural sort comparison function for titles
        function naturalCompare(a, b) {
            const ax = removeArticles(a);
            const bx = removeArticles(b);

            // Natural sorting algorithm that handles numbers correctly
            const chunks = /(\d+|\D+)/g;
            const aChunks = String(ax).match(chunks);
            const bChunks = String(bx).match(chunks);

            // Check if either string doesn't match the pattern
            if (!aChunks || !bChunks) return ax.localeCompare(bx);

            const len = Math.min(aChunks.length, bChunks.length);

            // Compare each chunk
            for (let i = 0; i < len; i++) {
                // If both chunks are numeric
                if (!isNaN(aChunks[i]) && !isNaN(bChunks[i])) {
                    // Convert to numbers and compare
                    const numA = parseInt(aChunks[i], 10);
                    const numB = parseInt(bChunks[i], 10);
                    if (numA !== numB) {
                        return numA - numB;
                    }
                } else {
                    // Regular string comparison
                    const stringComp = aChunks[i].localeCompare(bChunks[i]);
                    if (stringComp !== 0) {
                        return stringComp;
                    }
                }
            }

            // If all chunks were equal but strings have different lengths
            return aChunks.length - bChunks.length;
        }

        // Sort media data
        function sortMedia(data, method) {
            if (method === 'alpha') {
                // Sort alphabetically by title, ignoring articles and handling numbers naturally
                const sorted = [...data].sort((a, b) => {
                    return naturalCompare(a.title, b.title);
                });

                // Reverse the order if direction is descending (Z-A)
                return sortDirection[method] === 'asc' ? sorted : sorted.reverse();
            } else if (method === 'date') {
                // Sort by date added
                if (sortDirection[method] === 'desc') {
                    // Newest first (descending)
                    return [...data].sort((a, b) => b.addedAt - a.addedAt);
                } else {
                    // Oldest first (ascending)
                    return [...data].sort((a, b) => a.addedAt - b.addedAt);
                }
            }
            return data;
        }

        // Filter and sort media based on search term and sort method
        function filterAndSortMedia(searchTerm) {
            const activeTab = document.querySelector('.tab.active').dataset.content;
            const data = activeTab === 'movies' ? moviesData : tvShowsData;

            // First filter by search term
            let filtered = data.filter(item =>
                item.title.toLowerCase().includes(searchTerm)
            );

            // Then filter by genre if necessary
            if (currentGenre !== 'all') {
                filtered = filtered.filter(item =>
                    item.genres && item.genres.includes(currentGenre)
                );
            }

            // Sort the filtered data using the current sort method
            const sortedData = sortMedia(filtered, currentSortMethod);

            // Display the sorted data
            displayMedia(sortedData, activeTab);
        }

        // Display media items with enhanced animations
        function displayMedia(data, type) {
            const contentDiv = document.querySelector(`#${type}-content`);
            const loadingDiv = contentDiv.querySelector('.loading');
            const grid = contentDiv.querySelector('.media-grid');
            const noResultsDiv = contentDiv.querySelector('.no-results');

            // Hide loading spinner
            loadingDiv.style.display = 'none';

            // Always start with an empty grid
            grid.innerHTML = '';

            // Check if there are no results to display
            if (data.length === 0) {
                // Get the current search term
                const searchTerm = document.querySelector('.search-input').value;

                // Update the no results message content first
                if (currentGenre !== 'all') {
                    contentDiv.querySelector('.no-results-message').innerHTML =
                        `We couldn't find any ${type === 'movies' ? 'Movies' : 'TV Shows'} 
                         in the "${currentGenre}" genre${searchTerm ? ` matching "<span class="search-term">${searchTerm}</span>"` : ''}`;
                } else {
                    contentDiv.querySelector('.no-results-message').innerHTML =
                        `We couldn't find any ${type === 'movies' ? 'Movies' : 'TV Shows'} 
                         matching "<span class="search-term">${searchTerm}</span>"`;
                }

                // Show no results message and hide the grid
                noResultsDiv.classList.add('active');
                grid.style.display = 'none';

                // Make sure genre dropdown or drawer gets closed when showing no results
                document.querySelectorAll('.genre-menu').forEach(menu => {
                    menu.classList.remove('show');
                });

                return;
            }

            // We have results to display
            noResultsDiv.classList.remove('active');
            grid.style.display = 'grid';

            // Create and append items with staggered animation
            data.forEach((item, index) => {
                const mediaItem = document.createElement('div');
                mediaItem.className = 'media-item';
                mediaItem.dataset.id = item.id;
                mediaItem.dataset.type = type;
                mediaItem.style.opacity = '0';
                mediaItem.style.transition = `opacity 0.3s ease ${index * 0.03}s, transform 0.3s ease ${index * 0.03}s`;

                const posterPath = type === 'movies' ?
                    `data/posters/movies/${item.id}.jpg` :
                    `data/posters/tvshows/${item.id}.jpg`;

                // Format the added date
                const addedDate = formatDate(item.addedAt);

                // Get primary genre if available
                const primaryGenre = item.genres && item.genres.length > 0 ? item.genres[0] : 'Unknown';

                mediaItem.innerHTML = `
                    <div class="poster-container">
                        <div class="poster-placeholder">
                            <div class="loading-spinner"></div>
                        </div>
                        <img data-src="${posterPath}" 
                             alt="${item.title}" 
                             class="poster">
                    </div>
                    <div class="media-info">
                        <div class="media-title">${item.title}</div>
                        <div class="media-year">${item.year}</div>
                        <div class="media-added">Added: ${addedDate}</div>
                    </div>
                `;

                grid.appendChild(mediaItem);

                // Trigger animation after a small delay
                setTimeout(() => {
                    mediaItem.style.opacity = '1';
                }, 10);

                // Observe the image for lazy loading
                const img = mediaItem.querySelector('.poster');
                imageObserver.observe(img);

                // Add click event to open modal
                mediaItem.addEventListener('click', () => {
                    openModal(item, type);
                });
            });
        }

        // Modal functionality
        const modalOverlay = document.querySelector('.modal-overlay');
        const modalClose = document.querySelector('.modal-close');

        // Function to open modal with media details
        function openModal(item, type) {
            // Set poster image
            const posterPath = type === 'movies' ?
                `data/posters/movies/${item.id}.jpg` :
                `data/posters/tvshows/${item.id}.jpg`;

            const posterContainer = document.querySelector('.modal-poster');
            posterContainer.innerHTML = ''; // Clear existing content

            const posterImg = document.createElement('img');
            posterImg.src = posterPath;
            posterImg.alt = item.title;
            posterContainer.appendChild(posterImg);

            posterImg.onerror = function () {
                // Remove the failed image
                this.remove();

                // Create a large text placeholder
                const placeholder = document.createElement('div');
                placeholder.className = 'text-placeholder large';

                placeholder.innerHTML = `
                    <div class="media-name">${item.title}</div>
                `;

                posterContainer.appendChild(placeholder);
            };

            // Set backdrop image
            const backdropPath = type === 'movies' ?
                `data/backdrops/movies/${item.id}.jpg` :
                `data/backdrops/tvshows/${item.id}.jpg`;

            const backdropElement = document.querySelector('.modal-backdrop');
            backdropElement.innerHTML = ''; // Clear any existing content
            backdropElement.style.backgroundImage = `url(${backdropPath})`;

            // Add error handling for backdrop
            const testImage = new Image();
            testImage.onload = function () {
                // Image loaded successfully, keep the backdrop
            };
            testImage.onerror = function () {
                // Image failed to load, remove background image
                backdropElement.style.backgroundImage = 'none';

                // Add text-based placeholder
                const backdropPlaceholder = document.createElement('div');
                backdropPlaceholder.className = 'backdrop-text-placeholder';

                if (type === 'movies') {
                    backdropPlaceholder.textContent = 'Movie';
                } else {
                    backdropPlaceholder.textContent = 'TV Show';
                }

                backdropElement.appendChild(backdropPlaceholder);
            };
            testImage.src = backdropPath;

            // Set title and year
            document.querySelector('.modal-title').textContent = item.title;
            document.querySelector('.modal-year').textContent = item.year || '';

            // Set metadata
            const ratingElem = document.getElementById('modal-rating');
            const durationElem = document.getElementById('modal-duration');

            // Handle content rating
            if (item.contentRating) {
                ratingElem.textContent = item.contentRating;
                ratingElem.style.display = 'block';
            } else {
                ratingElem.style.display = 'none';
            }

            // Handle duration (for movies) or episode/season count (for TV shows)
            if (type === 'movies' && item.duration) {
                // For movies, show duration in minutes
                const minutes = Math.floor(item.duration / 60000);
                durationElem.textContent = `${minutes} min`;
                durationElem.style.display = 'block';

                // Hide seasons element (in case it was visible from previous TV show)
                const seasonsElem = document.getElementById('modal-seasons');
                if (seasonsElem) {
                    seasonsElem.style.display = 'none';
                }

                // Hide episodes element (in case it was visible from previous TV show)
                const episodesElem = document.getElementById('modal-episodes');
                if (episodesElem) {
                    episodesElem.style.display = 'none';
                }
            } else if (type === 'tvshows') {
                // For TV shows, show seasons and episodes in separate containers

                // First, ensure the seasons element exists
                let seasonsElem = document.getElementById('modal-seasons');
                if (!seasonsElem) {
                    // Create a new element for seasons if it doesn't exist
                    seasonsElem = document.createElement('div');
                    seasonsElem.className = 'metadata-item';
                    seasonsElem.id = 'modal-seasons';

                    // Insert it before the duration element
                    durationElem.parentNode.insertBefore(seasonsElem, durationElem);
                }

                // Create or get the episodes element
                let episodesElem = document.getElementById('modal-episodes');
                if (!episodesElem) {
                    // Create a new element for episodes if it doesn't exist
                    episodesElem = document.createElement('div');
                    episodesElem.className = 'metadata-item';
                    episodesElem.id = 'modal-episodes';

                    // Insert it after the seasons element
                    seasonsElem.parentNode.insertBefore(episodesElem, seasonsElem.nextSibling);
                }

                // Hide the duration element for TV shows
                durationElem.style.display = 'none';

                // Handle season count
                if (item.childCount) {
                    seasonsElem.textContent = `${item.childCount} ${item.childCount === 1 ? 'season' : 'seasons'}`;
                    seasonsElem.style.display = 'block';
                } else {
                    seasonsElem.style.display = 'none';
                }

                // Handle episode count
                if (item.leafCount) {
                    episodesElem.textContent = `${item.leafCount} ${item.leafCount === 1 ? 'episode' : 'episodes'}`;
                    episodesElem.style.display = 'block';
                } else {
                    episodesElem.style.display = 'none';
                }
            } else {
                // Default case - hide all elements
                durationElem.style.display = 'none';

                const seasonsElem = document.getElementById('modal-seasons');
                if (seasonsElem) {
                    seasonsElem.style.display = 'none';
                }

                const episodesElem = document.getElementById('modal-episodes');
                if (episodesElem) {
                    episodesElem.style.display = 'none';
                }
            }

            // Set summary
            document.getElementById('modal-summary').textContent = item.summary || 'No summary available.';

            // Set genres
            const genresContainer = document.getElementById('modal-genres');
            genresContainer.innerHTML = '';

            if (item.genres && item.genres.length > 0) {
                item.genres.forEach(genre => {
                    const genreElement = document.createElement('div');
                    genreElement.className = 'genre-tag';
                    genreElement.textContent = genre;

                    // Add click event to filter by this genre when clicked
                    genreElement.addEventListener('click', () => {
                        setGenreFilter(genre);

                        // Close modal
                        closeModal();
                    });

                    genresContainer.appendChild(genreElement);
                });
            } else {
                genresContainer.innerHTML = '<div>No genres available</div>';
            }

            // Set cast
            const castContainer = document.getElementById('modal-cast');
            castContainer.innerHTML = '';

            if (item.actors && item.actors.length > 0) {
                item.actors.forEach(actor => {
                    const actorElement = document.createElement('div');
                    actorElement.className = 'cast-item';
                    actorElement.innerHTML = `
                        <div class="cast-name">${actor.name}</div>
                        <div class="cast-role">${actor.role || ''}</div>
                    `;
                    castContainer.appendChild(actorElement);
                });
            } else {
                castContainer.innerHTML = '<div>No cast information available</div>';
            }

            // Add date added information
            const dateAdded = formatDate(item.addedAt);

            // Check if we already have the added date element
            let dateAddedElem = document.getElementById('modal-added-date');
            if (!dateAddedElem) {
                // Create a new section for date added
                const dateSection = document.createElement('div');
                dateSection.className = 'modal-section date-section';
                dateSection.innerHTML = `
                    <div class="modal-section-title">Date Added</div>
                    <div id="modal-added-date">${dateAdded}</div>
                `;
                document.querySelector('.modal-body').appendChild(dateSection);
            } else {
                // Update existing date info
                dateAddedElem.textContent = dateAdded;
            }

            // Make sure any previous modal content is reset before showing new modal
            const modalBody = document.querySelector('.modal-body');
            modalBody.scrollTop = 0;

            // Show modal with animation
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            modalOverlay.classList.add('active');

            // Double attempt to reset scroll after modal is visible
            // This addresses timing issues on mobile devices
            setTimeout(() => {
                // First reset
                modalBody.scrollTop = 0;

                // Second delayed reset with forced reflow (critical for mobile browsers)
                setTimeout(() => {
                    modalBody.scrollTop = 0;
                    // Force layout recalculation on mobile
                    void modalBody.offsetHeight;
                }, 50);
            }, 10);
        }

        // Close modal functionality
        modalClose.addEventListener('click', function (e) {
            e.preventDefault(); // Prevent event propagation
            e.stopPropagation(); // Stop event bubbling
            closeModal();
        });

        // Close modal when clicking outside
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeModal();
            }
        });

        // Close modal with escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modalOverlay.classList.contains('active')) {
                closeModal();
            }
        });

        // Function to close the modal
        function closeModal() {
            modalOverlay.classList.remove('active');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Initialize on page load
        loadMedia();

        // Enhanced scroll to top button functionality
        const scrollToTopButton = document.querySelector('.scroll-to-top');

        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                scrollToTopButton.classList.add('visible');
            } else {
                scrollToTopButton.classList.remove('visible');
            }
        });

        scrollToTopButton.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Header scroll effect - shrink on scroll
        const header = document.querySelector('.header');
        let lastScrollTop = 0;

        window.addEventListener('scroll', () => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > 100) {
                header.style.boxShadow = '0 2px 15px rgba(0, 0, 0, 0.3)';
            } else {
                header.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
            }

            lastScrollTop = scrollTop;
        });

        // ==========================================
        // SWIPE FUNCTIONALITY FOR MOBILE
        // ==========================================

        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;

        if (isMobile) {
            // Variables to track swipe
            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0;
            let touchEndY = 0;
            let swipeThreshold = 100; // Minimum distance to be considered a swipe
            let swipeAngleThreshold = 30; // Maximum angle in degrees to be considered a horizontal swipe

            // Get swipe indicator element
            const swipeIndicator = document.querySelector('.swipe-indicator');

            // Show swipe tip on first load for mobile users
            setTimeout(() => {
                swipeIndicator.textContent = 'Swipe left or right to switch between Movies and TV Shows';
                swipeIndicator.style.opacity = '1';

                // Hide the tip after 3 seconds
                setTimeout(() => {
                    swipeIndicator.style.opacity = '0';
                }, 3000);
            }, 2000);

            // Add touch event listeners to the container
            const container = document.querySelector('.container');

            container.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, false);

            container.addEventListener('touchmove', (e) => {
                // Prevent default only if we detect a significant horizontal movement
                // This allows vertical scrolling to continue working normally
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;

                const diffX = touchStartX - currentX;
                const diffY = touchStartY - currentY;

                // If horizontal movement is greater than vertical and exceeds threshold
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > swipeThreshold) {
                    e.preventDefault();
                }
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                handleSwipe();
            }, false);

            // Handle swipe gesture
            function handleSwipe() {
                // Calculate distances and angle
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;
                const angle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;

                // Check if swipe is horizontal enough (angle less than threshold)
                if (angle < swipeAngleThreshold) {
                    // Don't process swipes when modal is open
                    if (modalOverlay.classList.contains('active')) {
                        return;
                    }

                    // Get current active tab
                    const activeTab = document.querySelector('.tab.active').dataset.content;

                    // Calculate swipe distance and direction
                    const distance = Math.abs(diffX);

                    if (distance > swipeThreshold) {
                        let switched = false;

                        if (diffX > 0) {
                            // Swiped left, show TV Shows
                            if (activeTab === 'movies') {
                                switched = true;
                                swipeIndicator.textContent = 'Switched to TV Shows';
                                switchTab('tvshows');
                            }
                        } else {
                            // Swiped right, show Movies
                            if (activeTab === 'tvshows') {
                                switched = true;
                                swipeIndicator.textContent = 'Switched to Movies';
                                switchTab('movies');
                            }
                        }

                        // Only show the indicator if we actually switched tabs
                        if (switched) {
                            swipeIndicator.style.opacity = '0.9';

                            // Hide indicator after 1.5 seconds
                            setTimeout(() => {
                                swipeIndicator.style.opacity = '0';
                            }, 1500);
                        }
                    }
                }
            }
        }

        // Server toggle functionality
        function toggleServer() {
            const currentPath = window.location.pathname;
            let newPath;

            if (currentPath === "/" || currentPath === "/index.html") {
                newPath = "SERVER_PATH/";
            } else if (currentPath.startsWith("/plex/")) {
                newPath = "/jellyfin/";
            } else if (currentPath.startsWith("/jellyfin/")) {
                newPath = "/plex/";
            } else {
                newPath = "SERVER_PATH/";
            }

            window.location.href = newPath;
        }

    </script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        // Add install prompt
        let deferredPrompt;
        const installButton = document.createElement('button');
        installButton.style.display = 'none';
        installButton.classList.add('install-button');
        installButton.textContent = 'Install App';

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;

            // Create and show the install button - position after the H1
            installButton.style.display = 'block';

            // Get the logo section and h1 element
            const logoSection = document.querySelector('.logo-section');

            // Insert the button right after the h1 element inside the logo section
            logoSection.appendChild(installButton);

            installButton.addEventListener('click', (e) => {
                // Hide the install button
                installButton.style.display = 'none';
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                });
            });
        });

        // Add styles for the install button
        const style = document.createElement('style');
        style.textContent = `
            .install-button {
                background-color: var(--primary-color);
                color: #000;
                border: none;
                border-radius: 20px;
                padding: 8px 15px;
                font-weight: 600;
                cursor: pointer;
                margin-left: 15px;
                transition: background-color 0.3s;
                align-self: center;
            }
            .install-button:hover {
                background-color: var(--primary-hover);
            }
            .logo-section {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            @media screen and (max-width: 768px) {
                .install-button {
                    margin-left: 15px;
                    margin-right: -15px;
                    padding: 6px 12px;
                    font-size: 0.85rem;
                }
            }
        `;
        document.head.appendChild(style);
    </script>

    <!-- Add this at the end of the body, just before the closing </body> tag -->

    <!-- Trailer Modal -->
    <div class="trailer-modal-overlay">
        <div class="trailer-modal-content">
            <button class="trailer-modal-close" aria-label="Close trailer">×</button>
            <div class="trailer-container">
                <!-- Loading indicator will be inserted here -->
                <div class="trailer-loading">
                    <div class="trailer-spinner"></div>
                    <div class="trailer-loading-text">Loading trailer...</div>
                </div>
                <!-- Iframe will be inserted here dynamically -->
            </div>
        </div>
    </div>

    <style>
        /* Watch Trailer Button */
        .modal-actions {
            display: flex;
            margin-top: 15px;
        }

        .watch-trailer-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--primary-color);
            color: #000;
            border: none;
            border-radius: 20px;
            padding: 8px 16px;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background-color var(--transition-speed);
        }

        .watch-trailer-btn:hover {
            background-color: var(--primary-hover);
        }

        .trailer-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }


        /* Trailer Modal */
        .trailer-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity var(--transition-speed) ease;
        }

        .trailer-modal-overlay.active {
            display: flex;
            opacity: 1;
        }

        .trailer-modal-content {
            position: relative;
            width: 90%;
            max-width: 1000px;
            background-color: transparent;
        }

        .trailer-container {
            position: relative;
            padding-bottom: 56.25%;
            /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .trailer-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
            /* Ensure iframe appears above loading indicator */
            background-color: #000;
        }

        /* Loading Indicator */
        .trailer-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(26, 26, 26, 0.7);
            z-index: 5;
            /* Lower z-index than iframe */
            border-radius: 8px;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .trailer-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(229, 160, 13, 0.2);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: trailer-spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes trailer-spin {
            to {
                transform: rotate(360deg);
            }
        }

        .trailer-loading-text {
            color: var(--light-text);
            font-weight: 500;
        }

        .trailer-loading.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .trailer-modal-close {
            position: absolute;
            top: -40px;
            right: 0px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: var(--light-text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color var(--transition-speed);
            z-index: 20;
            /* Higher than iframe */
        }

        .trailer-modal-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Improved mobile styling */
        @media screen and (max-width: 768px) {
            .trailer-modal-content {
                width: 95%;
            }

            .trailer-modal-close {
                /* Position in the top-right corner of the video container */
                right: 0px;
                /* Make the button larger and more visible */
                top: -45px;
                width: 40px;
                height: 40px;
                font-size: 24px;
                /* Add more contrast */
                background-color: rgba(0, 0, 0, 0.7);
                z-index: 25;
                /* Ensure it's above the video */
            }

            .trailer-spinner {
                width: 40px;
                height: 40px;
            }
        }
    </style>

    <script>
        // Modify the modal HTML to include the Watch Trailer button
        document.addEventListener('DOMContentLoaded', function () {
            // Add the Watch Trailer button to the modal title section
            const modalTitleSection = document.querySelector('.modal-title-section');
            const modalActions = document.createElement('div');
            modalActions.className = 'modal-actions';
            modalActions.innerHTML = `
        <button class="watch-trailer-btn">
        <span class="trailer-icon" aria-hidden="true">
            <svg
            class="play-icon"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
            >
            <path d="M8 5v14l11-7L8 5z" />
            </svg>
        </span>
        Watch Trailer
        </button>
`;
            modalTitleSection.appendChild(modalActions);

            // Get trailer modal elements
            const trailerModalOverlay = document.querySelector('.trailer-modal-overlay');
            const trailerContainer = document.querySelector('.trailer-container');
            const trailerModalClose = document.querySelector('.trailer-modal-close');
            const trailerModalContent = document.querySelector('.trailer-modal-content');
            const trailerLoading = document.querySelector('.trailer-loading');

            // Check if we're on a mobile device
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;

            // Function to open trailer modal with the correct title and year
            function openTrailerModal(title, year) {
                // Show the loading indicator
                trailerLoading.classList.remove('hidden');

                // Clear previous iframe
                const existingIframe = trailerContainer.querySelector('iframe');
                if (existingIframe) {
                    existingIframe.remove();
                }

                // Show trailer modal
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
                trailerModalOverlay.classList.add('active');

                // Create iframe with the movie title AND year
                const encodedTitle = encodeURIComponent(title);
                const iframe = document.createElement('iframe');
                iframe.src = `https://tvtime.dev/glimpse?title=${encodedTitle}&year=${year}&embed=true&autoplay=true`;
                iframe.setAttribute('frameborder', '0');
                iframe.setAttribute('allowfullscreen', 'true');

                // Set initial opacity to 0
                iframe.style.opacity = '0';
                iframe.style.transition = 'opacity 0.3s ease';

                // Add load event listener to hide the loading indicator
                iframe.onload = function () {
                    // Set a short delay before showing the iframe to wait for content inside to load
                    setTimeout(() => {
                        // Hide the loading indicator
                        trailerLoading.classList.add('hidden');

                        // Show the iframe
                        iframe.style.opacity = '1';
                    }, 700); // Short delay for better user experience - adjust if needed
                };

                // Add error event listener
                iframe.onerror = function () {
                    // Update loading indicator to show error
                    trailerLoading.innerHTML = `
            <div class="trailer-loading-text" style="color: #ff4444;">
                Failed to load trailer. Please try again later.
            </div>
        `;
                };

                // Add the new iframe
                trailerContainer.appendChild(iframe);

                // Set a timeout to hide the loading indicator even if onload doesn't trigger
                // This can happen with some embedded content
                setTimeout(() => {
                    trailerLoading.classList.add('hidden');
                    iframe.style.opacity = '1';
                }, 3000); // Reduced timeout to 3 seconds
            }

            // Function to close trailer modal
            function closeTrailerModal() {
                trailerModalOverlay.classList.remove('active');

                // Only restore scrolling if the main modal is not open
                if (!modalOverlay.classList.contains('active')) {
                    document.body.style.overflow = '';
                }

                // Remove iframe after animation completes to stop playback
                setTimeout(() => {
                    if (!trailerModalOverlay.classList.contains('active')) {
                        // Reset the loading indicator for next time
                        trailerLoading.classList.remove('hidden');
                        trailerLoading.innerHTML = `
                <div class="trailer-spinner"></div>
                <div class="trailer-loading-text">Loading trailer...</div>
            `;

                        // Remove the iframe to stop playback
                        const existingIframe = trailerContainer.querySelector('iframe');
                        if (existingIframe) {
                            existingIframe.remove();
                        }
                    }
                }, 300);
            }

            // Close trailer modal when clicking the close button
            trailerModalClose.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                closeTrailerModal();
            });

            // Close trailer modal when clicking outside
            trailerModalOverlay.addEventListener('click', (e) => {
                if (e.target === trailerModalOverlay) {
                    closeTrailerModal();
                }
            });

            // Close trailer modal with escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && trailerModalOverlay.classList.contains('active')) {
                    closeTrailerModal();
                }
            });

            // Store reference to the original openModal function
            const originalOpenModal = window.openModal;

            // Override the openModal function to add trailer button functionality
            window.openModal = function (item, type) {
                // Call the original function first
                originalOpenModal(item, type);

                // Get the trailer button
                const trailerBtn = document.querySelector('.watch-trailer-btn');

                // Only show the trailer button for movies, not TV shows
                if (type === 'movies') {
                    trailerBtn.style.display = 'flex';

                    // Add click event to open trailer with both title and year
                    trailerBtn.onclick = () => {
                        openTrailerModal(item.title, item.year);
                    };
                } else {
                    trailerBtn.style.display = 'none';
                }
            };

            // Store reference to the original closeModal function
            const originalCloseModal = window.closeModal;

            // Override the closeModal function to also close trailer modal if open
            window.closeModal = function () {
                // Call the original function first
                originalCloseModal();

                // Also close trailer modal if it's open
                if (trailerModalOverlay.classList.contains('active')) {
                    closeTrailerModal();
                }
            };
        });
    </script>

    <!-- Roulette Button HTML will be injected into the header -->

    <!-- Roulette Modal Overlay -->
    <div class="roulette-overlay">
        <div class="roulette-modal">
            <div class="roulette-spinner-container">
                <div class="roulette-spinner">
                    <div class="spinner-item"></div>
                    <div class="spinner-item"></div>
                    <div class="spinner-item"></div>
                </div>
                <div class="finding-text">Finding something for you...</div>
            </div>
            <!-- Error buttons only shown when needed -->
            <div class="roulette-error-buttons" style="display: none;">
                <button class="roulette-close-btn">Close</button>
            </div>
        </div>
    </div>

    <style>
        /* Roulette Button Styles */
        .roulette-button {
            background-color: var(--tab-bg);
            color: #fff;
            border-radius: 30px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            border: none;
            font-weight: 600;
            font-size: 0.9rem;
            white-space: nowrap;
            height: 36px;
        }

        .roulette-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .roulette-icon {
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Mobile styling */
        @media screen and (max-width: 768px) {
            .roulette-text {
                display: none;
            }

            .roulette-button {
                padding: 8px;
                width: 36px;
                height: 36px;
                justify-content: center;
                margin-left: 15px;
            }

            /* Position inside search box */
            .search-box {
                display: flex !important;
                align-items: center;
            }

            .search-container {
                flex: 1;
            }
        }

        /* Roulette Overlay Styles */
        .roulette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 1500;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .roulette-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .roulette-modal {
            background-color: var(--secondary-bg);
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            padding: 30px 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: translateY(30px);
            transition: transform 0.3s ease;
        }

        .roulette-overlay.active .roulette-modal {
            transform: translateY(0);
        }

        /* Spinner Animation */
        .roulette-spinner-container {
            margin-bottom: 20px;
        }

        .roulette-spinner {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            margin-top: 20px;
        }

        .spinner-item {
            width: 18px;
            height: 18px;
            background-color: var(--primary-color);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .spinner-item:nth-child(1) {
            animation-delay: -0.32s;
        }

        .spinner-item:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1);
            }
        }

        .finding-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--light-text);
            margin-top: 10px;
        }

        /* Button Styles */
        .roulette-error-buttons {
            justify-content: center;
            margin-top: 20px;
        }

        .roulette-close-btn {
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            background-color: var(--primary-color);
            color: #000;
        }

        .roulette-close-btn:hover {
            background-color: var(--primary-hover);
        }

        /* Responsive Styles */
        @media screen and (max-width: 768px) {
            .roulette-modal {
                width: 95%;
                padding: 25px 15px;
            }

            .finding-text {
                font-size: 1.1rem;
            }
        }

        @media screen and (max-width: 480px) {
            .roulette-modal {
                width: 95%;
                padding: 20px 10px;
            }
        }

        /* Hide when modal is open */
        .modal-overlay.active~.roulette-button,
        .trailer-modal-overlay.active~.roulette-button,
        .roulette-overlay.active~.roulette-button {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Get elements
            const rouletteOverlay = document.querySelector('.roulette-overlay');
            const rouletteModal = document.querySelector('.roulette-modal');
            const errorButtons = document.querySelector('.roulette-error-buttons');
            const findingText = document.querySelector('.finding-text');

            // Create and add the roulette button to the header
            function createRouletteButton() {
                // Create the button element
                const rouletteButton = document.createElement('div');
                rouletteButton.className = 'roulette-button';
                rouletteButton.innerHTML = `
                <div class="roulette-icon">🎲</div>
                <span class="roulette-text">Roll the Dice</span>
            `;

                // Find the right place to insert it in the header
                const headerContent = document.querySelector('.header-content');
                const searchBox = document.querySelector('.search-box');
                const mobileMenuButton = document.querySelector('.mobile-menu-button');

                // On mobile, insert the button inside the search box after the search container
                if (window.innerWidth <= 768) {
                    const searchContainer = searchBox.querySelector('.search-container');
                    searchBox.appendChild(rouletteButton);
                } else {
                    // On desktop, insert before the mobile menu button if it exists, otherwise at the end
                    if (mobileMenuButton) {
                        headerContent.insertBefore(rouletteButton, mobileMenuButton);
                    } else {
                        headerContent.appendChild(rouletteButton);
                    }
                }

                // Add click event listener
                rouletteButton.addEventListener('click', openRoulette);

                // Handle window resize to reposition the button as needed
                window.addEventListener('resize', handleResize);

                function handleResize() {
                    const isMobile = window.innerWidth <= 768;

                    // Reposition button based on screen size
                    if (isMobile && !searchBox.contains(rouletteButton)) {
                        // Move to search box for mobile
                        searchBox.appendChild(rouletteButton);
                    } else if (!isMobile && searchBox.contains(rouletteButton)) {
                        // Move back to header for desktop
                        if (mobileMenuButton) {
                            headerContent.insertBefore(rouletteButton, mobileMenuButton);
                        } else {
                            headerContent.appendChild(rouletteButton);
                        }
                    }
                }

                return rouletteButton;
            }

            // Create the button
            const rouletteButton = createRouletteButton();

            // Array to store filtered items based on current view
            let filteredItems = [];
            // Track already selected items to avoid repeats
            let selectedIndices = new Set();
            // Current content type (movies or tvshows)
            let currentContentType = '';
            // Last selected item
            let lastSelectedItem = null;
            // Flag to track if the modal was opened via random selection
            let modalOpenedViaRoulette = false;

            // Messages for the animation
            const messages = [
                "Finding something for you...",
                "Searching for the perfect match...",
                "How about this one?",
                "This might be interesting...",
                "Let's try this one...",
                "Picking something special...",
                "Spinning the wheel of entertainment...",
                "Discovering hidden gems..."
            ];

            // Function to open the roulette overlay
            function openRoulette() {
                // Determine current content type
                const activeTab = document.querySelector('.tab.active');
                currentContentType = activeTab ? activeTab.dataset.content : 'movies';

                // Get current filtered data
                if (currentContentType === 'movies') {
                    // Get currently visible movies (respecting filters)
                    const visibleItems = getVisibleItems();
                    filteredItems = visibleItems.length > 0 ? visibleItems : moviesData;
                } else {
                    // Get currently visible TV shows (respecting filters)
                    const visibleItems = getVisibleItems();
                    filteredItems = visibleItems.length > 0 ? visibleItems : tvShowsData;
                }

                // Reset the set if we've seen most of the items
                if (selectedIndices.size >= filteredItems.length * 0.7) {
                    selectedIndices.clear();
                }

                // Show the overlay
                rouletteOverlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent background scrolling

                // Start the roulette animation
                startRouletteAnimation();
            }

            // Function to get visible items in the current view
            function getVisibleItems() {
                const visibleItems = [];
                const mediaItems = document.querySelectorAll('.media-item');

                // Check which grid is currently active
                const activeContent = document.querySelector('.content.active');
                if (!activeContent) return [];

                // Get all visible media items in the active grid
                activeContent.querySelectorAll('.media-item').forEach(item => {
                    // Only consider visible items
                    if (getComputedStyle(item).display !== 'none') {
                        const itemId = item.dataset.id;
                        const itemType = item.dataset.type;

                        // Find the item in the dataset
                        const mediaArray = itemType === 'movies' ? moviesData : tvShowsData;
                        const mediaItem = mediaArray.find(m => m.id === itemId);

                        if (mediaItem) {
                            visibleItems.push(mediaItem);
                        }
                    }
                });

                return visibleItems;
            }

            // Function to select a random item
            function selectRandomItem() {
                if (filteredItems.length === 0) return null;

                // Find an index we haven't used recently
                let randomIndex;
                let attempts = 0;
                const maxAttempts = filteredItems.length;

                do {
                    randomIndex = Math.floor(Math.random() * filteredItems.length);
                    attempts++;

                    // If we've tried too many times, just use any index
                    if (attempts >= maxAttempts) break;
                } while (selectedIndices.has(randomIndex));

                // Add this index to our set of used indices
                selectedIndices.add(randomIndex);

                return filteredItems[randomIndex];
            }

            // Function to start the roulette animation
            function startRouletteAnimation() {
                // Reset the finding text
                updateFindingText();

                // Start the message changing animation
                let messageIndex = 0;
                const messageInterval = setInterval(() => {
                    messageIndex = (messageIndex + 1) % messages.length;
                    findingText.textContent = messages[messageIndex];
                }, 1500);

                // After animation delay, select and show the item
                setTimeout(() => {
                    clearInterval(messageInterval);

                    // Select a random item
                    const selectedItem = selectRandomItem();
                    lastSelectedItem = selectedItem;

                    if (selectedItem) {
                        // Close the roulette overlay
                        closeRoulette();

                        // Set the flag to true before opening the modal
                        modalOpenedViaRoulette = true;

                        // Use the existing modal to display the selected item
                        openModal(selectedItem, currentContentType);
                    } else {
                        // If no item could be selected, show an error message
                        findingText.textContent = "No items available to select";

                        // Show the error button
                        errorButtons.style.display = 'flex';
                        const closeBtn = document.querySelector('.roulette-close-btn');

                        // Add event listener to close button
                        if (closeBtn) {
                            closeBtn.addEventListener('click', closeRoulette);
                        }
                    }
                }, 2500); // Animation runs for 2.5 seconds
            }

            // Function to update the finding text randomly
            function updateFindingText() {
                findingText.textContent = messages[Math.floor(Math.random() * messages.length)];
            }

            // Function to close the roulette overlay
            function closeRoulette() {
                rouletteOverlay.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling

                // Hide error buttons if they were shown
                errorButtons.style.display = 'none';
            }

            // Button click event listeners
            // Note: the button click event is now added during button creation

            // Close on overlay click
            rouletteOverlay.addEventListener('click', function (e) {
                if (e.target === rouletteOverlay) {
                    closeRoulette();
                }
            });

            // Close with Escape key
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && rouletteOverlay.classList.contains('active')) {
                    closeRoulette();
                }
            });

            // Add a button to the modal to try again
            function addTryAgainToModal() {
                // Only add the button if the modal was opened via roulette
                if (!modalOpenedViaRoulette) return;

                // Check if we already added the button
                if (document.querySelector('.modal-try-again-btn')) return;

                // Create the style for the new button
                const style = document.createElement('style');
                style.textContent = `
                .modal-actions {
                    display: flex;
                    margin-top: 15px;
                    flex-wrap: wrap;
                    gap: 10px;
                }
                
                .modal-try-again-btn {
                    background-color: var(--tab-bg);
                    color: var(--light-text);
                    border: none;
                    border-radius: 20px;
                    padding: 8px 16px;
                    font-weight: 600;
                    font-size: 0.95rem;
                    cursor: pointer;
                    transition: background-color var(--transition-speed);
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
                
                /* Fix for mobile layout */
                @media (max-width: 480px) {
                    .modal-actions {
                        flex-direction: column;
                        width: 100%;
                    }
                    
                    .modal-try-again-btn,
                    .watch-trailer-btn {
                        width: 100%;
                        justify-content: center;
                    }
                }
                
                .modal-try-again-btn:hover {
                    background-color: rgba(255, 255, 255, 0.1);
                }
                
                .dice-icon {
                    font-size: 1.1rem;
                }
            `;
                document.head.appendChild(style);

                // Create the button and add it to the modal actions
                const tryAgainBtn = document.createElement('button');
                tryAgainBtn.className = 'modal-try-again-btn';
                tryAgainBtn.innerHTML = '<span class="dice-icon">🎲</span> Roll Again';

                // Add the event listener
                tryAgainBtn.addEventListener('click', function () {
                    // Close the current modal
                    closeModal();

                    // Open the roulette overlay and start a new selection
                    setTimeout(() => {
                        openRoulette();
                    }, 300);
                });

                // Add the button to the modal actions
                const modalActions = document.querySelector('.modal-actions');
                if (modalActions) {
                    modalActions.appendChild(tryAgainBtn);
                }
            }

            // Override the openModal function to conditionally show the try again button
            const originalOpenModal = window.openModal;
            window.openModal = function (item, type) {
                // Call the original function
                originalOpenModal(item, type);

                // Only add the button if the modal was opened via roulette
                if (modalOpenedViaRoulette) {
                    setTimeout(addTryAgainToModal, 10);
                }
            };

            // Override the closeModal function to reset the flag
            const originalCloseModal = window.closeModal;
            window.closeModal = function () {
                // Call the original function
                originalCloseModal();

                // Reset the flag when the modal is closed
                modalOpenedViaRoulette = false;

                // Remove the try again button if it exists
                const tryAgainBtn = document.querySelector('.modal-try-again-btn');
                if (tryAgainBtn) {
                    tryAgainBtn.remove();
                }
            };
        });
    </script>

    <script>

        // Code to add to ensure date sort is properly applied when set as default
        function applyDefaultSortStyles() {
            // If current sort method is 'date', update all UI elements accordingly
            if (currentSortMethod === 'date') {
                // Add body class for showing added dates
                document.body.classList.add('sort-by-date');

                // Update all sort buttons to reflect 'date' as the active sort
                document.querySelectorAll('.sort-button').forEach(btn => {
                    if (btn.dataset.sort === 'date') {
                        btn.classList.add('active');
                        // Update the icon/text
                        const iconSpan = btn.querySelector('.sort-icon');
                        if (iconSpan) {
                            iconSpan.textContent = sortDirection['date'] === 'desc'
                                ? '📅 Date Added ▼'
                                : '📅 Date Added ▲';
                        }
                    } else if (btn.dataset.sort === 'alpha' && !btn.classList.contains('genre-button')) {
                        btn.classList.remove('active');
                    }
                });
            }
        }

        // We need to apply the sort styles early, before data is loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Apply default sort styles right after DOM content is loaded
            setTimeout(applyDefaultSortStyles, 0);
        });

        // Also maintain the function hook for after media is loaded
        const originalLoadMedia = loadMedia;
        loadMedia = async function () {
            await originalLoadMedia();
            // Apply styles again after data is loaded to ensure everything is in sync
            applyDefaultSortStyles();
        };
    </script>

</body>

</html>